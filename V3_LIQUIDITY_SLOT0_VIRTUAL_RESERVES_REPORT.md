## TL;DR (самое важное)

- **`slot0.sqrtPriceX96`** = текущая цена пула (в виде $\sqrt{P}$ в fixed‑point Q96), где $P=\frac{\text{token1}}{\text{token0}}$.
- **`liquidity()`** = **текущая активная (in‑range) ликвидность $L$** — сумма ликвидности **только тех позиций**, чей диапазон включает текущую цену.
- Зная **$\sqrt{P}$** и **$L$**, можно посчитать **“virtual reserves”**:
  - $x=\frac{L}{\sqrt{P}}$ (условный “reserve0”)
  - $y=L\cdot\sqrt{P}$ (условный “reserve1”)
  - и дальше применять **ту же формулу CPAMM**, что и для V2 (с учётом fee).
- Это **точно** описывает своп **только пока цена не пересекает следующий “инициализированный” тик** (то есть пока $L$ не меняется).
- Для **больших** свопов, которые проходят **через много тиков**, одних `slot0+liquidity` **недостаточно**: нужно читать **tick bitmap + ticks** и делать **tick‑walk** (как в view‑quoter), иначе можно сильно ошибиться в слиппедже.

---

## Простое объяснение Uniswap/Pancake V3 для человека из мира V2 (CPAMM)

### Как мыслить про V2

В V2 есть **2 числа** в стейте: `reserve0`, `reserve1`.

- Цена: $P=\frac{reserve1}{reserve0}$
- Кривая: $k=reserve0\cdot reserve1$ (постоянное произведение)
- Чем больше резервы — тем меньше слиппедж.

### Что в V3 принципиально иначе

В V3 ликвидность **не размазана на весь диапазон цен**. LP выбирают диапазоны (тики):

- позиция $[tickLower, tickUpper)$ добавляет ликвидность $L$ **только внутри этого диапазона**
- если цена ушла выше диапазона — позиция становится “в одном токене”
- если цена ниже — тоже “в одном токене”, но в другом

Из‑за этого “глубина” пула меняется **скачками** на границах диапазонов.

### Что такое “инициализированный тик”

Тик считается **инициализированным**, если в этом тике есть **изменение активной ликвидности**:

- у него `liquidityGross > 0` (какие‑то позиции на этом тике стартуют/заканчиваются)
- и есть `liquidityNet` (сколько $L$ надо прибавить/убавить при пересечении этого тика)

Pool хранит:

- `tickBitmap` — какие тики инициализированы (битовая карта)
- `ticks[tick]` — `liquidityGross`, `liquidityNet` и др.

### Что значит “current in-range liquidity”

`liquidity()` возвращает **одно число $L$**: сумму ликвидностей **всех позиций**, для которых выполняется:

$$
tickLower \le tickCurrent < tickUpper
$$

Это **не** “вся ликвидность пула вообще”, а только активная **прямо сейчас** (по текущей цене).

### Твой пример с тиками

Пусть есть 3 LP‑позиции:

- LP1: $[800, 1200)$
- LP2: $[1000, 1200)$
- LP3: $[400, 2000)$

Тогда инициализированные тики (границы диапазонов) здесь: **400, 800, 1000, 1200, 2000**.

Активная ликвидность (то, что вернёт `liquidity()`):

- **между 400 и 800**: активен только LP3 → $L = L_3$
- **между 800 и 1000**: активны LP1 + LP3 → $L = L_1 + L_3$
- **между 1000 и 1200**: активны LP1 + LP2 + LP3 → $L = L_1 + L_2 + L_3$
- **между 1200 и 2000**: активен только LP3 → $L = L_3$

Ты пишешь: “последний свап был **покупка token0**, цена token0 растёт, тик с 800 → 1000”.

Да — это означает, что цена двигалась вверх, и при пересечении тика 1000 **включился** LP2 (его диапазон начинается с 1000), то есть активная ликвидность $L$ **увеличилась** на $L_2$.

### Что такое `slot0` и что он нам показывает

`slot0` — это “упакованный” слот хранилища, который возвращает сразу пачку значений, главное для нас:

- `sqrtPriceX96` = $\sqrt{P}$ в Q96
- `tick` = текущий tick (логарифмическая цена)

То есть `slot0` даёт **текущую цену**, а `liquidity()` — **текущую активную глубину** (но только в одном сегменте).

### Мини‑пример: как из `sqrtPriceX96` получить цену (на “игрушечном Q”, чтобы было интуитивно)

В реальном Uniswap V3/Pancake V3:

- $Q96 = 2^{96}$
- `sqrtPriceX96 = sqrt(P) * Q96`

Чтобы не оперировать огромными числами, заменим масштаб на “игрушечный”:

- пусть $Q = 1000$ (вместо $2^{96}$)
- пусть реальная $\sqrt{P} = 1.500$

Тогда “sqrtPriceX96‑аналог”:

- `sqrtPriceXQ = sqrt(P) * Q = 1.500 * 1000 = 1500`

Как восстановить цену $P$:

$$
\sqrt{P}=\frac{sqrtPriceXQ}{Q}=\frac{1500}{1000}=1.5
$$

$$
P=(\sqrt{P})^2=1.5^2=2.25
$$

То есть если $P=\frac{token1}{token0}$, это означает:

- **1 token0 стоит 2.25 token1**

Почему в формулах в коде появляются умножения/деления на $Q96$:

- `sqrtPriceX96` хранит $\sqrt{P}$ “умноженную” на $Q96$
- чтобы получить $\sqrt{P}$ в нормальном виде — надо делить на $Q96$
- чтобы обратно работать целыми числами без float — мы оставляем $Q96$ внутри формул как масштаб

Именно поэтому в нашем приближении “virtual reserves”:

- $reserve0 \approx \frac{L}{\sqrt{P}}$ превращается в `L * Q96 / sqrtPriceX96`
- $reserve1 \approx L \cdot \sqrt{P}$ превращается в `L * sqrtPriceX96 / Q96`

### Как V3 считает своп внутри одного диапазона (пока $L$ не меняется)

Внутри диапазона между “инициализированными” тиками активная ликвидность $L$ **постоянна**.

Обозначим:

- $\sqrt{P}$ = текущая $\sqrt{\frac{token1}{token0}}$
- $\sqrt{P'}$ = новая $\sqrt{P}$ после свопа (в пределах этого же диапазона)

Тогда без комиссий:

- если **вводим token1 и выводим token0** (цена растёт):

  - $amount1 = L\cdot(\sqrt{P'}-\sqrt{P})$
  - $amount0 = L\cdot\left(\frac{1}{\sqrt{P}}-\frac{1}{\sqrt{P'}}\right)$

- если **вводим token0 и выводим token1** (цена падает) — формулы симметричны (двигаемся к меньшей $\sqrt{P'}$).

Главная интуиция:

- $L$ — это “наклон/глубина” кривой **в текущем диапазоне**
- чем больше $L$, тем больше объём можно обменять при том же изменении цены

### Почему “virtual reserves” приводят V3 к модели V2 (в одном диапазоне)

Определим “виртуальные резервы”:

$$
x=\frac{L}{\sqrt{P}}, \qquad y=L\cdot\sqrt{P}
$$

Тогда:

- $\frac{y}{x}=P$ (та же цена)
- $x\cdot y=L^2$ — “постоянное произведение” в этом диапазоне

То есть **внутри одного диапазона с фиксированным $L$** V3 математически ведёт себя как **CPAMM** на резервах $(x, y)$.

Именно это мы и используем в прототипе.

### Но где “доступный объём ликвидности для свапа” на самом деле ограничен

Чтобы понять “сколько можно свапнуть”, надо знать **границы диапазона** в направлении движения цены.

Например, если цена растёт (ввод token1, вывод token0), то максимум до следующего инициализированного тика сверху:

- $maxAmount1 = L\cdot(\sqrt{P_{upper}}-\sqrt{P})$
- $maxAmount0 = L\cdot\left(\frac{1}{\sqrt{P}}-\frac{1}{\sqrt{P_{upper}}}\right)$

Проблема: **`slot0+liquidity` не говорят, где следующий инициализированный тик** и какой у него $\sqrt{P_{upper}}$.

Поэтому:

- для маленьких объёмов (не доходящих до границы) — оценка точная/почти точная
- для больших — можно ошибиться, потому что при пересечении тика $L$ прыгает (часто сильно)

---

## Ответ на твой прямой вопрос: “slot0 + liquidity достаточно?”

### Для чего достаточно

- Для **быстрой оценки** цены/слиппеджа **в текущем диапазоне**
- Для **сравнения пулов** и **первичного оптимального split** (мы так и делаем сейчас)

### Для чего НЕ достаточно

- Для **точного расчёта** `amountOut` на больших `amountIn`, когда цена проходит через несколько инициализированных тиков
- Для гарантии `minAmountOut` на‑чейне без дополнительной проверки (tick‑walk / quoter)

Именно поэтому в “финальном” on-chain плане обычно делают:

- быстрый фильтр по `slot0+liquidity` на все 10 пулов
- точный пересчёт (tick‑walk / view‑quoter) только на топ‑кандидатах перед исполнением

---

## Как устроены файлы `src/evm/` в текущем прототипе (что за что отвечает)

### `multicallPools.js`

- Делает **snapshot** стейта пулов одним `eth_call` через Multicall3.
- Для V3 вытаскивает минимум для текущей модели: `token0/token1/fee/tickSpacing/slot0/liquidity`.

### `evmPoolMath.js`

- Нормализует разные DEX/версии в один интерфейс:
  - fee V2 (Uniswap/Pancake) и fee V3 (1e6‑скейл)
  - V2 reserves из `getReserves()`
  - V3 reserves как **virtual reserves** из `slot0+liquidity`
- Даёт CPAMM‑квотер `quoteExactIn(...)`.

### `evmSplitOptimizer.js`

- Реализует оптимальный split exact‑in по concave функции:

$$
out(x)=\frac{c_N\cdot x\cdot R_{out}}{c_D\cdot R_{in}+c_N\cdot x}
$$

- Делает бинарный поиск по $\lambda$, чтобы распределить общий `amountIn` между пулами.

### `evmSwapPlanner.js`

- Высокоуровневый “планировщик”:
  - нормализует `target/quote`, `BUY/SELL`
  - строит кандидаты по пулам
  - приводит разные quote‑токены к одной базе через `rates`
  - считает `bestSingle` и `bestSplit`

### `evmMathBigInt.js`

- Набор BigInt‑утилит, чтобы не использовать float:
  - `parseUnits/formatUnits`
  - `mulDiv`
  - `isqrt`
  - константа `Q96` для `sqrtPriceX96`

### `EX-runSwapPlanner.js`

- Демонстрационный запуск BUY и SELL на `EX-poolsStates.js`.

---

## Как работает вся математика в нашем Node.js коде

### 1) Мы реально читаем у V3‑пула именно `slot0` и `liquidity()`

- `src/evm/multicallPools.js`
  - для `kind === "v3"` добавляем вызовы `slot0()` и `liquidity()` в Multicall
  - декодим `slot0.sqrtPriceX96` и `liquidity`

### 2) Из `slot0.sqrtPriceX96 + liquidity` строим “virtual reserves”

- `src/evm/evmPoolMath.js`:
  - `getV3VirtualReserves(pool)` берёт:
    - `pool.slot0.sqrtPriceX96`
    - `pool.liquidity`
  - и возвращает:
    - `reserve0 = L * Q96 / sqrtPriceX96`
    - `reserve1 = L * sqrtPriceX96 / Q96`

### 3) Дальше V3 идёт по той же CPAMM-формуле, что и V2

- `src/evm/evmPoolMath.js`:
  - `quoteExactIn(amountIn, reserveIn, reserveOut, feeNum, feeDen)`
- `src/evm/evmSwapPlanner.js`:
  - `buildCandidate()` вызывает `getReserveInOut()` → внутри V3 тоже вернёт virtual reserves
  - затем `evmSplitOptimizer.quoteOut()` считает `out(x)` по CPAMM‑формуле и оптимизатор решает split
